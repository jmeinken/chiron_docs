
(autocreate-the-data-dictionary)=
# 2. Autocreate the Data Dictionary

Creating a data dictionary by hand when you have a lot of fields is tedious. So we have a script that
can autocreate a data dictionary for you. You will define a list of {ref}`sources<source-def>` you want to import, then
the script will inspect the fields in those sources and create a full data dictionary turning each
field into a {ref}`concept<concept-def>`.

The autocreation tool is intentionally limited in how much it can be customized. The goal isn't to
give a perfect, complete data dictionary. The goal is to quickly get to a starting point that can then
be further customized as needed. You will only run this script once to get started. Then you will not
need to run it again unless you have new sources/fields that you want to import.

Currently the autocomplete script supports data coming from the Django ORM or from CSV files.

## Source List Overview

Your source list will have one entry for each {ref}`source<source-def>` you want to create. A source
can be any Python iterable, but for autocreate it will either be a Django model or a CSV file.

You can make a single source list for your chiron instance, or separate into multiple lists to
keep things logically separated.

A source list has the following structure:

```python

from chiron.data_dictionary.csv_autocreate import CsvFileAutocreate
from chiron.data_dictionary.django_autocreate import DjangoOrmAutocreate

my_source_list = {

    # Specify the autocreate class to use, either CsvFileAutocreate or DjangoOrmAutocreate
    "autocreate_tool": CsvFileAutocreate,

    # optionally set default values for this list, they will automatically be added to 
    # each item in the list unless that item specfies a different value
    "defaults": {
        # any arguments you want to use for all list entries
    },

    # create one entry for each Django Model or CSV file you want to import
    "list": [
        {
            "unique_source_id": "demographics",
            # additional optional and required arguments
        },
        {
            "unique_source_id": "encounters",
            # additional optional and required arguments
        },
        ...
    ],
}

```

## Source List Args for CSV Files

NOTE: Your CSV files must have a header row with the name of each field.

- **unique_source_id** *(str, required)*
    - This ID will be used in the {ref}`AutocreatedField table<autocreated-field-model>` to track whether this source has already been loaded. As long as this name doesn't change, fields will not be reloaded multiple times even if the filename changes.
- **filename** *(str, required)* 
    - If {ref}`CHIRON_SOURCE_DATA_DIRECTORY<chiron-settings-file-location>` is defined in Django settings, the relative filepath from that. Otherwise, the full filepath.
- **dataset** *(str, required if your system has >1 dataset)* 
    - The dataset as specified in {ref}`Dataset.unique_id<dataset-model>`
- **load_to_root** *(bool, default=False)* 
    - Each dataset has only one root (subject) collection. Set to True to load data to this collection (i.e. if this data is 1:1 with a subject).
- **collection** *(str, optional)* 
    - The permanent ID of the {ref}`collection<collection-model>` you want to load into. If `load_to_root=True`, this value will be ignored. If this value is not set, the `unique_source_id` will be used.
- **category** *(str, optional)* 
    - The name of the {ref}`category<category-model>` to associate these fields with. If this value is not set, the `unique_source_id` will be used.
- **collection_id_field** (str, optional) 
    - The header name of the field that identifies a unique record in this collection. If this is a subject collection (i.e. `load_to_root=True`), this value is ignored. If not set, a collection ID will be autogenerated.
- **subject_id_field** *(str, required if `subject_matching` is not set)*
    - The header name of the field that identifies the subject.
    - For more complex situations, use `subject_matching` instead.
- **subject_matching** *(dict, required if `subject_id_field` is not set)*
    - Use to define more complex subject matching rules than simply specifying a `subject_id_field`
    - The subject_matching dict can contain the following values:
        - **source_id_field** *(str, required)*
            - The header name of the field that identifies the subject.
        - **source_id_delimiter** *(str, optional)*
            - If the source_id_field can contain multiple subject_ids, what is the delimiter
            - default is None for no delimiter
        - **destination_id_field** *(str, default="id")*
            - The name of the subject ID field that gets stored in MongoDB.
            - If you only use one subject ID across all sources for your project, you can leave blank to use "id"
              for everything. But if you have multiple (ex. study_id and mrn) use this to specify
              which to match on.
        - **if_no_match** *(str, default="create")*
            - What do you want to do if the specified subject doesn't exist in the database yet?
            - Options are "create" to make a new subject and "skip" to ignore this subject.
- **add_subject_ids** *(list, optional)*
    - Use to add subject ID fields from this source without actually matching on them. You would want
      to do this in a situation where a later source will match on the added ID(s).
    - The add_subject_ids is a list of dicts each containing the following values:
        - **source_id_field** *(str, required)*
            - The header name of the field that identifies the subject.
        - **source_id_delimiter** *(str, optional)*
            - If the source_id_field can contain multiple subject_ids, what is the delimiter
            - default is None for no delimiter
        - **destination_id_field** *(str, default="id")*
            - The name of the subject ID field that will get stored in MongoDB.
  
## Source List Args for Django Models

- **app** *(str, required)*
    - The name of the Django app for the model you want to load.
- **model** *(str, required)*
    - The name of the Django model class you want to load.
- **source_name** *(str, optional)*
    - Provide a name to call the {ref}`source<source-model>`. Default value is the model name.
- **dataset** *(str, required if your system has >1 dataset)* 
    - The dataset as specified in {ref}`Dataset.unique_id<dataset-model>`
- **load_to_root** *(bool, default=False)* 
    - Each dataset has only one root (subject) collection. Set to True to load data to this collection (i.e. if this data is 1:1 with a subject).
- **collection** *(str, optional)* 
    - The permanent ID of the {ref}`collection<collection-model>` you want to load into. If `load_to_root=True`, this value will be ignored. If this value is not set, the `source_name` will be used.
- **category** *(str, optional)* 
    - The name of the {ref}`category<category-model>` to associate these fields with. If this value is not set, the `source_name` will be used.
- **collection_id_field** (str, optional) 
    - The model field that identifies a unique record in this collection. Foreign keys can be followed into other models using Django's double-underscore notation (ex "patient__patient_id"). If this is a subject collection (i.e. `load_to_root=True`), this value is ignored. The default value is the primary key for the model. If you want to autogenerate a random collection ID instead, you should explicitly set this value to None.
- **subject_id_field** *(str, required if `subject_matching` is not set)*
    - The model field for the subject ID. Foreign keys can be followed into other models using Django's double-underscore notation (ex "patient__patient_id").
    - For more complex situations, use `subject_matching` instead.
- **subject_matching** *(dict, required if `subject_id_field` is not set)*
    - Use to define more complex subject matching rules than simply specifying a `subject_id_field`
    - The subject_matching dict can contain the following values:
        - **source_id_field** *(str, required)*
            - The model field for the subject ID. Foreign keys can be followed into other models using Django's double-underscore notation (ex "patient__patient_id").
        - **destination_id_field** *(str, default="id")*
            - The name of the subject ID field that gets stored in MongoDB.
            - If you only use one subject ID across all sources for your project, you can leave blank to use "id"
              for everything. But if you have multiple (ex. study_id and mrn) use this to specify
              which to match on.
        - **if_no_match** *(str, default="create")*
            - What do you want to do if the specified subject doesn't exist in the database yet?
            - Options are "create" to make a new subject and "skip" to ignore this subject.
        - **workflow** *(list of strings, optional)*
            - There are a limited number of options for manipulating the source_id value string.
              - current options are "upper", "lower", "remove_leading_zeros"
            - Manipulation steps will be applied in order.
- **add_subject_ids** *(list, optional)*
    - Use to add subject ID fields from this source without actually matching on them. You would want
      to do this in a situation where a later source will match on the added ID(s).
    - The add_subject_ids is a list of dicts each containing the following values:
        - **source_id_field** *(str, required)*
            - The model field for the subject ID. Foreign keys can be followed into other models using Django's double-underscore notation (ex "patient__patient_id").
        - **destination_id_field** *(str, default="id")*
            - The name of the subject ID field that will get stored in MongoDB.
- **join_models** (list of dicts, optional)
    - You can take advantage of Django model relationships to join multiple models that will load together into a single collection.
    - In general, anything you add here through joins should be something you expect to be 1:1 with the main source model. 
    - For example, if you're loading a model Visit into a Chiron visit collection, you could join in another model like VisitQuestionnaire assuming that there's only one questionnaire per visit. 
    - You wouldn't want to join in something 1:many with visit like VisitDiagnosis - that should instead be set up as a separate source with its own dedicated diagnosis collection.
    - Each dict entry will have 3 values:
      - **app** (str, optional) - The Django app name where this model is. Default value is same as the main source model.
      - **model** (str, required) - The name of the model class you want to join.
      - **join_path** - The lookup path from the main source model to this model. This should use [Django's lookup notation](https://docs.djangoproject.com/en/4.0/topics/db/queries/#lookups-that-span-relationships-1). You can traverse any type of relationship (1:1, many:1, 1:many, many:many) and cross multiple relationships using a double underscore.
        - *example 1*: You have a Patient model and a Demographics model. The Demographics model has a ForeignKey field `patient` pointing to the Patient model. If your main source model is the Patient model, you could join in the demographics model using the join path `demographics_set`. If you don't understand where the "_set" suffix is coming from, see Django's documentation on [related names](https://docs.djangoproject.com/en/4.0/ref/models/relations/).
        - *example 2*: Continuing with the setup from example 1, if Demographics has a field `race` that has a many:many relationship to model RaceLookup, you could also join RaceLookup into Patient using the join path `deographics_set__race`. 
  
## How to run the autocreate script

Once your source list(s) are set up, you are ready to run the autocreate script. First collect
all your source lists together into one Python dictionary. The key values can be anything you want:

```python
autocreate_source_lists = {
  "system1": system1_source_list,
  "system2": system2_source_list,
}
```

Then you can use the Django setting {ref}`CHIRON_AUTOCREATE_SOURCE_LISTS<chiron-settings-file-location>` to tell Chiron the Python path where your
variable is stored. The default value is `chiron_config.autocreate.autocreate_source_lists`.

Then run the script:

```python
# check to see if your source lists are configured correctly without modifying anything
python manage.py chiron_autocreate_dd --test-run

# run the script
# If you have multiple source lists in your autocreate_source_lists dict, you will be prompted to 
# select a source source list or run all source lists.
python manage.py chiron_autocreate_dd
```

## Rerunning Autocreate After Changes

There is a dedicated model {ref}`AutocreatedField<autocreated-field-model>` to keep track of all fields that have been loaded through autocreate. Any fields that have been imported are tracked in this model and will not be imported again, even if the associated Concepts have been modified or deleted. So it is safe to rerun {ref}`chiron_autocreate_dd<management-chiron-autocreate-dd>` to autocreate concepts from new models, CSV files, or fields. It will not re-create any fields that have already been created.

If you actually want to reload previously loaded concepts (for example, if you deleted something by accident), you can remove the fields you wish to re-import from {ref}`AutocreatedField<autocreated-field-model>`, then run {ref}`chiron_autocreate_dd<management-chiron-autocreate-dd>` again.



