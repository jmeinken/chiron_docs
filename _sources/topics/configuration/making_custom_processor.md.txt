# Custom Processors and Concept Handlers

The **processor classes** control how data is loaded into MongoDB from data sources and how it is
displayed and queried. Chiron has a variety of :ref:`built-in-processors` that you can use
without writing any code. However, if you need customized behavior beyond what's already provided,
you can create your own processors.

## Getting Started With Custom Processors

Custom processors are classes that you will write in your code. These classes can go anywhere, but
we recommend creating a root-level package in your project called chiron_config and create an
additional package inside that called processors. Do not put them directly inside the chiron app,
as that will make it harder to update chiron in the future.

Once your custom processors are written, you need to register them with Chiron. Source
processors are registered with Chiron directly. The other three types of processors (ETL,
cohort def, and display) need to first be added to a concept handler. Then the concept handler
is registered with Chiron.

After a custom source processor is registered, it can be associated with any source
collection using the field `Source.processor`. Custom concept handlers can be
associated with any concept using the field `Concept.concept_handler`.

## Tips for Creating Custom Processors

Your custom processor can extend any of the chiron abstract processors in `chiron.processors.abstract`. Or if your processor is similar to an existing processor, it can extend one of the built-in processors in `chiron.processors`. The abstract processors have detailed comments that are hopefully useful.

### Common scenarios

**Getting data from a non-standard source such as an API**
- Create a custom source processor
- If your custor processor returns records as dictionaries, it can be registered and used with any of the built-in concept handlers that work with dictionaries.

**Generating a calculated field while loading data**
- Create a custom ETL processor. You will do the calculation in the `pull_concept_value_from_record()` method.
- Create a custom concept handler that extends a similar built-in concept handler. Use the `set_etl_processor()` method to add your custom ETL processor to it.
- Register your new concept handler with the source processor it will be used with.

**Generating a calculated field that depends on multiple data sources**

Sometimes you might want a caculated field that can only be determined by looking at data from multiple sources. The solution here is to load the relevant sources first, then iterate your MongoDB collection itself to do the calculation.

- You should already have your data dictionary configured to load any relevant input data you'll need.
- Add a new Source to your data dictionary that uses either the SourceSelf or SourceSelfSubdoc processors. Set the execution order value to run it later in the ETL process after relevant input data will have already been loaded.
- Create a custom ETL processor. See the SourceSelf and SourceSelfSubdoc processor notes to understand the format of returned records.
- Add your custom ETL processor to a concept handler, then register your concept handler.
- Now you can create a new Concept and associate your custom ETL processor and your new source.

(registering-custom-processors)=
## Registering Custom Processors

Source processors are registered with Chiron directly. The other three types of processors (ETL,
cohort def, and display) need to first be added to a concept handler. Then the concept handler
is registered with Chiron.

Registration is done in pairs. Each entry will include a source processor and concept handler that are allowed to be used together. For example, it you have a custom concept handler that can be used with the built-in SourceDjangoModel processor, you would register them together like this:

```python
from chiron.processors.registration import ProcessorRegistry
from chiron.processors import SourceDjangoModel

ProcessorRegistry.register(SourceDjangoModel, MyCustomHandler)
```

As a shorthand, you can register multiple source processors and multiple concept handlers at the same time. In this case, every source processor will be associated with every concept handler.

For example, if you have a custom source processor that returns records as Python dictionaries, you could do this:

```python
from chiron.processors.registration import ProcessorRegistry
from chiron.processors import DictCategoryHandler, DictTextHandler, DictDateHandler, DictFloatHandler, DictIntegerHandler

ProcessorRegistry.register(MySourceProcessor, [
   DictCategoryHandler,
   DictTextHandler,
   DictDateHandler,
   DictFloatHandler,
   DictIntegerHandler,
])
```

Tell Chiron in which modules your processors are registered. This can be done using the
CHIRON_PROCESSOR_MODULES setting. The default is to load the built-in Chiron processors. So you
will need to add the path to the package/module where your custom processors are:

```python
CHIRON_PROCESSOR_MODULES = ["chiron.processors", "chiron_config.processors"]
```

Note: If you include a module path, that module will be checked. If you include a package path,
the `__init__.py` of the package will be checked, but child modules will not be checked.

## Using Custom Processors in Your Data Dictionary

Once registered, your custom processors should become available in the data dictionary the
next time you run any python management command.

Use a custom source processor by setting it in `Source.processor`. Use a
custom handler by setting it in `Concept.concept_handler`.


## Abstract Processors

### SourceProcessor (abstract)

```{eval-rst}
.. autoclass:: chiron.processors.abstract.SourceProcessor
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```
   
#### StandardLoadMixin

```{eval-rst}
.. autoclass:: chiron.processors.abstract.StandardLoadMixin
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```

### EtlProcessor (abstract)

```{eval-rst}
.. autoclass:: chiron.processors.abstract.EtlProcessor
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```

```{eval-rst}
.. _cohort-def-processor-abstract:
```
   
### CohortDefProcessor (abstract)

```{eval-rst}
.. autoclass:: chiron.processors.abstract.CohortDefProcessor
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```

### CohortDefProcessorBuiltInUiMixin

```{eval-rst}
.. autoclass:: chiron.processors.abstract.CohortDefProcessorBuiltInUiMixin
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```

```{eval-rst}
.. _display-processor-abstract:
```

### DisplayProcessor (abstract)

```{eval-rst}
.. autoclass:: chiron.processors.abstract.DisplayProcessor
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```


## AggregationMethod Classes for Display Processors

Display processors store custom lists of aggregation methods that they allow. For example,
a numeric display processor will usually include the Average aggregation method, but a text
processor would not. You can use any of the built-in aggregation methods in your custom display
processor or create your own by extending the AggregationMethod abstract class.

### AggregationMethod (abstract base class)

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation._base.AggregationMethod
   :members:
   :private-members:
   :undoc-members:
   :show-inheritance:
```


### Average

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Average
   :show-inheritance:
```

### CountAll

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.CountAll
   :show-inheritance:
```

### CountDistinct

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.CountDistinct
   :show-inheritance:
```

### Earliest

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Earliest
   :show-inheritance:
```

### HasValue

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.HasValue
   :show-inheritance:
```

### HasValueText

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.HasValueText
   :show-inheritance:
```

### Latest

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Latest
   :show-inheritance:
```

### ListAll

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.ListAll
   :show-inheritance:
```

### ListDistinct

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.ListDistinct
   :show-inheritance:
```

### Max

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Max
   :show-inheritance:
```

### MaxDate

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.MaxDate
   :show-inheritance:
```

### Median

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Median
   :show-inheritance:
```

### Min

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.Min
   :show-inheritance:
```

### MinDate

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.MinDate
   :show-inheritance:
```

### MostFrequent

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.MostFrequent
   :show-inheritance:
```

### StdDev

```{eval-rst}
.. autoclass:: chiron.processors.display.aggregation.StdDev
   :show-inheritance:
```