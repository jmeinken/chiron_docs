# 4. Manually Edit the Data Dictionary

Here are some more things you might want to do after autocreating your dataset.

<hr>

## Define Concept Relationships

By default, every subcollection you create in your dataset will have a many:1 or many:many relationship to
the subject collection.

But there can also be relationships between subcollections. For example, you might have a `visit`
collection and a `procedure` collection where every procedure is associated with one visit. Use the
`ConceptRelationship` model to define these relationships. They must be set manually, they do not get autocreated.

<hr>

## Special ID Concept

Because of the way stacking/aggregation works in reports, it's usually good to have unique IDs for 
your various collections. For example, if a user wants to guarantee one row per procedure event, 
the easiest way to do this is by stacking results on a procedure event ID.

You might not have appropriate IDs available in your source data, or you might not have IDs 
you want to expose because of PHI restrictions. You might be tempted to create a random ID, 
but this would change every time the data is refreshed and cause problems with saved queries. 
Instead, use one of Chiron's specialized processors for generating auto IDs. These can be set up so 
that they don't change when the ETL is rerun.

### Subject IDs

**SITUATION: I have a PHI subject ID field in my source data, but I want users to see a deidentified ID.**

Using `AutoSubjectIdHandler`, you can provide your private subject ID as input and it will generate a
new deidentified subject ID.

*EXAMPLE:* {ref}`example5`

**SITUATION: I don't have a unique subject ID but I want one.**

Again you can use `AutoSubjectIdHandler`. But since you don't have an ID to use as input, you
need to provide a group of fields that together uniquely identify a subject (name, demographic details, etc.).

*EXAMPLE:* {ref}`example6`

**SITUATION: I used a subject ID field for subject matching and now want to expose it to users as a concept.**

ID fields used for subject matching between different sources are stored in your Mongo subject collection (in `_ids`)
but don't get exposed to users. One advantage of these fields is that they can be populated
from multiple sources - something that isn't possible with concepts. 

You can expose these IDs to users by copying the data into a regular Chiron concept using the 
`SubjectMatchingToTextHandler`.

*EXAMPLE:* {ref}`example7`

### Subcollection IDs

**SITUATION: I want to create a unique, deidentified ID for every record in my subcollection.**

Using `AutoSubcollectionIdHandler`, you can generate a deidentified subcollection ID using
other concepts(s) as input.

*EXAMPLE:* {ref}`example8`

## Custom Age/Date Concepts

For identifying when events happened, Chiron works down to the level of 1 day (times are not currently supported).
There are three types of input data you might have coming from your sources:

- **absolute date(s)** - includes DOB, DOD or start/end date of an event
- **age in years as float** - age at event in years as a float value (decimal indicates fraction of a year)
- **age in days as integer** - age at event as number of days old

And then Chiron has three types of date/age concepts available:

- **date**
    - use when you want to show absolute dates when things happen
	- applying PHI restrictions will round all dates to years in the UI
- **detailed age**
    - internally stores age as days old
    - gives a high level of detail without exposing dates, which are often PHI
- **current age**
    - always stores/shows a deidentified value
    - gives the patient's current age in years, or "90 and above"
     
Use this table to lookup your situation, based on what type of input data you have and what type of concept you want to create:

|Input format|Desired Chiron format|Approach|
|---|---|---|
|absolute date(s)|date|use {ref}`date-handler`|
|absolute date(s)|current age|{ref}`example9`|
|absolute date(s)|detailed age|{ref}`example10`|
|age in years as float|date|(not supported)|
|age in years as float|current age|use {ref}`current-age-handler`|
|age in years as float|detailed age|use {ref}`detailed-age-handler` with source_format="year float"|
|age in days as integer|date|(not supported)|
|age in days as integer|current age|(not supported)|
|age in days as integer|detailed age|use {ref}`detailed-age-handler`|

## Turning Collections into Events

TODO: add this section

## Create Calculated Concepts

Follow this guideline to choose how to implement a calculated concept.

### 1. Single source

**Is all of the input data you need for your calculated concept coming from the same source in the same record?**

Use a custom ETL processor associated with the same source collection as your input data.

*EXAMPLE:* {ref}`example1`


### 2. Mutiple sources

If the input data for your calculated concept is coming from multiple sources, the approach in
step 1 won't work because no source will have all the data you need.

Instead, we load all the sources containing our input data first, then we will create a new source
that iterates a Chiron collection itself and loads the calculated value back into the collection.
This new source has to run after our input data sources so that the data is already loaded.

**Are all of the input concepts in the subject collection?**

After the sources for the input concepts are loaded, we can use the `SourceSelf` processor to iterate the subject
colection.

*EXAMPLE:* {ref}`example2`

**Are all of the input concepts going into a subcollection (and associated subject)?**

We can use the `SourceSelfSubdoc` processor to iterate the subcollection. For each subcollection
record, it will also grab the related subject document from the subject collection.

*EXAMPLE:* {ref}`example3`

In some situations, the calculated concept might actually be comparing data longitudinally. For example,
you might want to calculate whether a patient's condition has improved or worsened by comparing each
visit to the previous visit. Again we can use the `SourceSelfSubdoc` processor, but we need to
provide the additional argument `include_related_subdocs=True`.

*EXAMPLE:* {ref}`example4`

